/*
 * Creates the pie chart widget, that allows you to create a pie chart.
 *
 * Supply your data as **[data]**, as a lambda node, as a label/value type of collection.
 * Optionally pass in **[has-legend]**, and set its value to boolean _"false"_, if you
 * do not want to have a legende associated with your pie chart. By default a legend
 * will be created, and it will have a width of 150px by default.
 *
 * The **[data]** items you supply does not need to add up to 100, they can be any numbers
 * you happen to have. The widget will calculate the relative values for each data item,
 * in comparison to the total value of all your items, and create a pie slice accordingly,
 * matching your items' values.
 *
 * Optionally add a **[size]** argument, which becomes the pie chart's width and height
 * in pixels. The default value is 250.
 *
 * You can also override the color of each data child, by providing a **[color]** argument,
 * at which point your item will be rendered with the specified color. The default colors are
 * taken from the rainbow's color, in order of appearance.
 *
 * Notice, the **[size]** argument is the actual width of the pie itself, implying the widget
 * as a whole, will require additional width and height, since it requires some space for its
 * legend, among other things.
 *
 * All other arguments will be passed in _"as is"_, implying you can override its CSS class,
 * create **[onclick]** event handlers for your chart, override style properties, etc.
 */
create-event:micro.widgets.chart.pie

  /*
   * Signal node, to separate arguments from the rest of our lambda.
   */
  .signal

  /*
   * Defaults, if no arguments are given.
   */
  .defaults
    class:micro-widgets-chart-pie
    has-legend:bool:true

  /*
   * Sanity checking invocation.
   */
  micro.lambda.contract.min:x:/..
    data

  /*
   * Calculating total amount of all [data] elements supplied.
   */
  .total:double:0
  for-each:x:/../*/data/*?value
    set:x:/@.total?value
      +:x:/@.total?value.double
        _:x:/@_dp?value

  /*
   * Looping through each [data] value, creating one "slice" for each [data] item,
   * making sure we store how much we need to rotate each pie, to offset rotation
   * from previous pie.
   */
  .current-angle:double:270
  for-each:x:/../*/data/*

    /*
     * Figuring out how much the currently iterated pie is of our total percentage.
     */
    /:x:/@_dp/#?value.double
      _:x:/@.total?value

    /*
     * Checking if color provided an explicit [color] for slice.
     */
    if:x:/@_dp/#/*/color
      eval-x:x:/+/**
      add:x:/..for-each/*/add/[1,2]/**/literal
        src
          stroke:x:/@_dp/#/*/color?value

    /*
     * Adding currently iterated pie piece to return widget.
     */
    add:x:/+2/**/literal
      src:x:/@_dp/#/*(!/stroke)
    eval-x:x:/+/**/style
    add:x:/../*/return/*/container/*/widgets
      src
        svg
          class:piece
          viewbox:"0 0 100 100"
          style:"transform: rotate({0}deg);"
            :x:/@.current-angle?value
          widgets
            literal
              element:circle
              r:25
              cx:50
              cy:50
              width:100
              height:100
              style:"stroke-dasharray:calc({0:#.####} * 157.07963) 157.07963;"
                :x:/..for-each/*/\/?value
    set:x:/@.current-angle?value
      +:x:/@.current-angle?value
        *:x:/..for-each/*/\/?value
          _:360

  /*
   * Checking if caller wants to have a legend for the pie chart.
   */
  if:x:(/../*/has-legend|/@.defaults/*/has-legend)/$?value.bool
    =:bool:true

    /*
     * Adding labels to return widget.
     */
    *:x:/../*/data/*?count
      _:20
    +:x:/-?value
      _:30
    eval-x:x:/+/**
    add:x:/../*/return/*/container/*/widgets
      src
        svg
          class:labels
          height:x:/@+?value
          widgets
    .no:int:1
    for-each:x:/../*/data/*
      *:x:/@.no?value
        _:20
      if:x:/@_dp/#/*/color?value
        eval-x:x:/+/**
        add:x:/..for-each/*/add/*/*/literal/[0,1]
          src
            fill:x:/@_dp/#/*/color?value
      eval-x:x:/+/**
      add:x:/../*/return/*/container/*/widgets/0/-/*/widgets
        src
          literal
            element:rect
            x:20
            y:x:/@*?value
            width:15
            height:15
          container
            element:foreignObject
            x:45
            y:x:/@*?value
            width:10
            widgets
              body
                widgets
                  span
                    innerValue:x:/@_dp/#?name
      set:x:/@.no?value
        +:x:/@.no?value
          _:1

  /*
   * Applying defaults to returned SVG element.
   */
  add:x:/../*/return/*/container
    src:x:(/@.signal/--|/@.defaults/*)/$(!/data!/size!/has-legend)
  eval-x:x:/+/*/*/style
  return
    container
      widgets
